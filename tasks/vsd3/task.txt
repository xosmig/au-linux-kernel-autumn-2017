В этом заднии мы сделаем наше виртуальное устройство хранения данных
(VSD) более похожим на реальное.

Теперь модуль vsd не просто создает VSD устройство на шине platform_bus
и выделяет для него буфер в ядерной памяти. Созданное на шине
platform_bus VSD устройство теперь представляет из себя отдельного
от vsd_driver агента, который получает команды от vsd_driver путем записи
их номера и аргументов в виртуальные регистры, расположенные в физической памяти
компьютера. Также через виртуальные регистры VSD возвращает результат выполнения команды
и уведомляет vsd_driver о завершении обработки команды.

Рассмотрим пример обработки команды на чтение VSD из userspace.

1. Userspace приложение аллоцирует буфер, в который должны прочитаться
   данные из VSD.

2. Userspace приложение выполняет системный вызов sys_read в файловый
   дескриптор, полученный при открытии ноды vsd_driver /dev/vsd

3. Пользовательский поток, находящийся в драйвере vsd_driver
   в обработчике системного вызова vsd_dev_read ждет пока
   VSD освободится (т.к. VSD выполняет запросы по одному) и получает
   VSD в монопольное пользование.

4. vsd_driver аллоцирует участок непрерывной физической памяти (почему?),
   достаточный для записи туда данных, которые хочет прочитать
   userspace приложение.

5. vsd_driver заполняет виртуальные регистры VSD - пишет туда адрес
   буфера физической памяти, его размер, смещение внутри VSD и номер
   команды "чтение" VSD_CMD_READ.

6. vsd_driver ставит поток в очередь ожидания (wait_queue)
   для ожидание завершения обработки команды VSD_CMD_READ устройством VSD.

7. У VSD есть свой "процессор" - поток, который раз в секунду проверяет
   состояние виртуальных регистров VSD и выполняет запрошенную команду,
   если таковая поступила.

8. VSD выполняет команду, кладет результат выполнения в виртуальные
   регистры и будит ожидающий поток, вставший в очереди ожидания
   (wait_queue).

9. Пробуждение осуществляется путем запуска "программного прерывания",
   а точнее tasklet, который при своем исполнении разбудит ожидающий
   в wait_queue поток.

10.Ожидающий поток просыпается, забирает результат выполнения из
   виртуальных регистров VSD, осовобождает VSD для пользования другими
   потоками и завершает системный вызов.

=========================================
Задание.

Реализуйте всю недостающую логику (все TODO).

Ваш код не должен содержать race conditions.
Для задания строгого порядка модификации виртуальных регистров
VSD устройства используйте макрос wmb().

Используйте тесты из userspace части задания.
