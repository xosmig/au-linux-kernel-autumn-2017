В данном задании мы добавим в vsd_driver поддержку двух режимов ввода-вывода:
1. Синхронного неблокирующего
2. Асинхронного блокирующего

===============================================
Синхронный блокирующий и неблокирующий ввод-вывод

vsd драйвер обрабатывает системные вызовы в режиме синхронного неблокирующего
ввода-вывода, когда на текущем файловом дескрипторе установлен флаг
O_NONBLOCK. В данном режиме если обработка системного вызова может
заблокироваться, то драйвер возвращает ошибку -EAGAIN.
Это общее правило обработки системных вызовов в данном режиме,
которое мы должны соблюдать во всем задании.
Никогда не блокируйтесь, если выполняете системный вызов в режиме
синхронного неблокирующего ввода-вывода. Нужно заблокироваться - возвращаете -EAGAIN.

В нашем задании мы реализуем поддержку синхронной неблокирующей записи
в vsd девайс. Для этого мы создадим внутри vsd драйвера очередь ожидающих
команд vsd девайса. vsd девайс должен выполнять команды из очереди
по одной. Таким образом реализация неблокирующей записи будет просто
добавлять команду в очередь и возвращать пользователю "успех".
Обратите внимание, что если команда была добавлена в очередь в режиме
блокирующего синхронного ввода-вывода, то поток, ожидающий завершения команды
должен быть разбужен. Если же команда была добавлена в режиме
синхронного неблокирубщего ввода-вывода, то ожидающего ее завершения
потока нет, а значит никого будить не надо. Заметим, что в
синхронном неблокирующем режиме мы не можем
вернуть ошибку в userspace после добавления команды в очередь,
а это значит что наше устройство не будет гарантировать успешного
завершения команды. Успешное завершение системного вызова будет лишь означать
успешное добавления команды в очередь исполнения.

Длина очереди ожидающих команд у нас будет ограничена константой
VSD_DEV_CMD_QUEUE_MAX_LEN.
Поэтому если мы находимся в режиме синхронного неблокирующего ввода-вывода
и очередь команд полна, то мы должны вернуть ошибку -EAGAIN в userspace
и не добавлять новую команду. Если же мы находимся в режиме синхронного
блокирующего ввода-вывода и очередь команд полна, то мы должны дождаться
пока в ней появится место для нашей команды, добавить ее в очередь и
дождаться ее завершения.

Также необходимо реализовать функции userspace библиотеки vsd_device,
отвечающие за работу в данном режиме.

===============================================
Асинхронный блокирующий ввод-вывод

Для поддержки данного режима работы в драйвере vsd девайса,
нам понадобится реализовать функцию poll в структуре file_operations
нашего драйвера.
Внутри функции poll мы должны сообщить ядру какие системные вызовы сейчас
не заблокируются при их вызове. Также нам надо дать знать
ядру с помощью структуры poll_table_struct в какой момент поменяется
набор системных вызовов, которые не заблокируются (оповещение может быть
false positive).
Например, в нашем задании хорошим событием по которому поменяется набор
неблокируемых системных вызовов может быть изменение длины очереди
команд.

Помните, что внутри функции poll нам нельзя блокироваться.

Также необходимо реализовать функции userspace библиотеки vsd_device,
отвечающие за работу в данном режиме.

Дополнительную информацию вы можете найти в книге Linux Device Drivers 3
в разделе "poll and select".

==============================================

На обе части задания написаны userspace тесты (vsd_test.c).
