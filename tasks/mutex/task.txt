В этом задании вам нужно будет разработать C библиотеку,
реализующую мьютексы в пространстве пользователя.
Наличие подобной библиотеки обязательно для большинства ОС.
По своей функциональности наша библиотека будет проще мьютексов
из библиотеки pthread, но зато она тоже будет достаточно производительной.

Код задания делится на 3 части:
1. Директория mutex_lib - интерфейс и реализация userspace части библиотеки
   мьютексов. Часть кода доступна для старта.
2. Тесты. Первый - бенчмарк ваших мьютексов. Второй - валидатор небольшой
   части операций над мьютексами без влияния гонок.
3. Ядерный модуль mutex_module - обеспечивает код mutex_lib поддержкой со
   стороны ядра. В нем находится вся функциональность, которую нельзя эффективно
   реализовать в userspace.

Интерфейс библиотеки mutex_lib находится в файле include/mutex.h.
Он прост и понятен. Посмотрим как он может быть реализован.

Мы бы могли реализовать каждый мьютекс как спинлок. Это довольно легко сделать.
Но при такой реализации наши мьютексы будут тратить очень много лишнего
процессорного времени и энергии.
Мы поступим так, как делают все нормальные реализации мьютексов.
При невозможности мгновенно захватить мьютекс, мы будем некоторое время
активно ждать его захвата (также как и делает спинлок).
Далее при достижении максимального количества циклов ожидания текущий поток должен
встать в очередь ожидания мьютекса и перестать планироваться планировщиком CPU.
После того как мьютекс освобожден, поток-бывший владелец должен
разбудить один поток из очереди ожидания мьютекса.

Теперь мы уточним, что пользоваться имеющимися API пространства пользователя
и системными вызовами ядра, предназначенными для реализации примитивов синхронизации
мы не можем. Поэтому будем реализовывать все сами.

Можно попробовать реализовать все в userspace без поддержки со стороны ядра.
Например, очередь потоков как структуру данных можно реализовать в userspace.
Но проблема в том, что в Linux и многих других POSIX совместимых системах нет
API для того чтобы безусловно поставить поток на ожидание и разбудить его.
Все что есть в Linux это futex - но это системный вызов для реализации примитивов
синхронизации, поэтому мы не можем его использовать.
Также стоит заметить, что наша очередь в userspace тоже должна как-то быть
защищена от одновременного доступа разными потоками. А примитивов синхронизации
в userspace у нас нет - мы моделируем ситуацию, когда мы сами пишем ОС и даем
эти API пользователям.

Таким образом, ждать освобождения мьютекса наши потоки могут только в ядре.
К счастью, в ядре уже есть такие API как wait queue - очередь ожидания потоков
и самые разные примитивы синхронизации. Ими мы и воспользуемся для реализации своих
мьютексов в пространстве пользователя.

Кажется, что мы могли бы каждому userspace мьютексу сопоставить ядерный объект mutex
и при попытке захватить userspace мьютекс делать системный вызов в ядро.
В ядре захватывать mutex с помощью mutex_lock и таким образом реализовать наши
userspace мьютексы. У данного решения есть критический недостаток - для освобождения
и взятия мьютекса нужно делать системный вызов. Мы хотим сделать достаточно
хорошую реализацию userspace мьютексов. А хорошая реализация работает быстро на fast
путях - не замедляет случаи, когда contention - борьба за мьютекс между потоками
минимальна. То есть захват свободного мьютекса должен работать максимально быстро.
Поэтому часть нашего мьютекса должна находиться в userspace. Этой части должно
быть достаточно для захвата свободного мьютекса. Какой примитив синхронизации,
захват которого в свободном состоянии делается одним CAS, можно легко реализовать
в userspace? Вторая часть нашего мьютекса, отвечающая за ожидание его освобождения
и побудку ожидающих его потоков должна находиться в ядре. Ранее мы поняли почему.

В ядре нашему мьютексу должна соответствовать очередь ожидающих его потоков
(wait queue). Работать с ней будем примерно так: если фиксированное кол-во попыток
активного захвата мьютекса в userspace (spin lock) не получилось, то делаем системный
вызов и встаем в очередь ожидания. При освобождении этого мьютекса (spin lock'а) в
userspace, если есть ожидающие мьютекс потоки, то освободивший мьютекс поток
делает системный вызов, где пробуждает один ожидающий поток.
Заметьте, что при низком contention на мьютексе мы не делаем системных вызовов
ни при взятии, ни при освобождении мьютекса.

Решение вглядит достаточно просто, пока мы не поймем, что в ядре для каждого процесса
нам нужно хранить очереди ожидания и другое состояние для всех мьютексов в процессе.
Все потоки процесса одновременно имеют доступ к этому состоянию, могут его менять,
например создавая в произвольное время новый мьютекс (очередь ожидания) или уничтожая его.
Соответственно, все потоки процесса работают с общим состоянием мьютексов процесса,
и мы не можем синхронизировать доступ к этому общему состоянию
с помощью обычного ядреного mutex или spinlock. Почему? Представьте, что в процессе
есть 100 мьютексов с высоким contention. Потоки при переключении в ядро для синхронизации
будут брать один и тот же ядерный мьютекс/spinlock для того, чтобы встать в очередь
ожидания или наоборот разбудить ожидающий поток. В итоге, 100 мьютексов с высоким
contention превращаются в 1 мьютекс с невероятно высоким contention.

Также заметим, что в ядре хранится состояние мьютексов для каждого процесса в системе.
Для каждого процесса мы храним все состояние его мьютексов.
Эти объекты мы кладем в ядерный список.
Внутри объекта, хранящего состояние всех мьютексов процесса, мы храним список
состояний каждого мьютекса в процессе. Эти списки и объекты нам понадобится модифицировать.
Процесс может быть "убит", модуль ядра для поддержки мьютексов может быть выгружен,
новый процесс может открыть файл символьного устройства /dev/mutex и создать новый
объект для хранения состояния мьютексов этого процесса. Также для каждого потока,
делающего системный вызов в ядро нужно уметь найти объект, хранящий состояние
мьютексов его процесса. Все это требует синхронизации.

Но как сделать так, чтобы синхронизация в ядре не превращала все userspace мьютексы
в один ядерный? Для этого нужно проанализировать основные самые нагруженные пути
исполнения в ядре и сделать их wait-free.

Fast path в нашей библиотеке мьютексов это взятие, освобождение мьютекса.
В реальных приложениях мьютексы, на которых есть высокий contention
создаются и уничтожаются очень редко. Поэтому нам нужно сделать так, чтобы
при взятии/освобождении userspace мьютекса в ядре не было блокировки на
ядерных объектах синхронизации. Заметим, что при взятии/освобождении userspace мьютекса
достаточно найти объекты, хранящие состояние мьютексов процесса текущего потока
и в этом состоянии найти объект, хранящий состояние захвачиваемого/освобождаемого
мьютекса (его wait queue). Поиск объекта и удержание ссылки на него являются
immutable операциями. Поэтому для того, чтобы поиск и удержание ссылки на
состояние мьютекса были неблокирующими нам достаточно гарантировать, что во время
поиска в списках состояний мьютексов/процессов эти списки будут консистентными,
а во время удержания ссылки, объекты, на которые ссылаются ссылки не будут уничтожены.

Мы явно видим здесь паттерн для reader/writer lock. Любая модификация списков и
создание/уничтожение объектов требует захвата ядерного лока на запись.
Поиск и удержание ссылки требуют захвата ядерного лока на чтение.
Но rw locks нам не подойдут, т.к. в них writers блокируют readers и, таким образом,
делают взятие/освобождение userspace мьютекса блокирующим.

В каком механизме синхронизации writers не блокируют readers? Это RCU. Его и нужно
использовать в этом задании для синхронизации доступа к ядерным структурам,
хранящим состояние userspace мьютексов.

=======================================================================================
Задание:
Реализуйте описанный дизайн библиотеки userspace мьютексов.
Интерфейс библиотеки, тесты, некоторые подсказки даны в стартовом коде задания.
Помните, что тесты не могут проверить все. Читайте и анализируйте свой код.

Для того чтобы userspace части задания собрались создайте в их директориях директории bin.
